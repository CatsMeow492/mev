{"version":3,"file":"app/api/edge/proxy/route.js","mappings":"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","sources":["webpack://_N_E/external commonjs \"node:async_hooks\"","webpack://_N_E/external commonjs \"node:buffer\"","webpack://_N_E/./src/app/api/edge/proxy/route.ts","webpack://_N_E/./src/app/api/edge/proxy/route.ts?d217","webpack://_N_E/"],"sourcesContent":["module.exports = require(\"node:async_hooks\");","module.exports = require(\"node:buffer\");","import { NextRequest, NextResponse } from 'next/server';\n\nexport const runtime = 'edge';\n\nexport async function GET(request: NextRequest) {\n  return handleProxyRequest(request, 'GET');\n}\n\nexport async function POST(request: NextRequest) {\n  return handleProxyRequest(request, 'POST');\n}\n\nexport async function PUT(request: NextRequest) {\n  return handleProxyRequest(request, 'PUT');\n}\n\nexport async function DELETE(request: NextRequest) {\n  return handleProxyRequest(request, 'DELETE');\n}\n\nexport async function OPTIONS(request: NextRequest) {\n  const headers = new Headers();\n  headers.set('Access-Control-Allow-Origin', '*');\n  headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n  headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');\n  headers.set('Access-Control-Max-Age', '86400');\n  \n  return new Response(null, {\n    status: 200,\n    headers: headers\n  });\n}\n\nasync function handleProxyRequest(request: NextRequest, method: string) {\n  try {\n    const { searchParams, pathname } = new URL(request.url);\n    const path = searchParams.get('path') || '';\n    \n    // Determine target service URL\n    const targetUrl = getTargetUrl(path);\n    if (!targetUrl) {\n      return NextResponse.json(\n        { error: 'Invalid service path' },\n        { status: 400 }\n      );\n    }\n    \n    // Validate authentication if required\n    const authResult = await validateAuthentication(request, path);\n    if (authResult.error) {\n      return NextResponse.json(\n        { error: authResult.error },\n        { status: authResult.status || 401 }\n      );\n    }\n    \n    // Apply rate limiting\n    const rateLimitResult = await checkRateLimit(request);\n    if (rateLimitResult.error) {\n      return NextResponse.json(\n        { error: rateLimitResult.error },\n        { \n          status: 429,\n          headers: {\n            'Retry-After': '60',\n            'X-RateLimit-Limit': '100',\n            'X-RateLimit-Remaining': '0',\n            'X-RateLimit-Reset': Math.floor(Date.now() / 1000 + 60).toString()\n          }\n        }\n      );\n    }\n    \n    // Prepare headers for backend request\n    const headers = new Headers();\n    headers.set('Content-Type', request.headers.get('Content-Type') || 'application/json');\n    headers.set('User-Agent', 'MEV-Dashboard-Proxy/1.0');\n    headers.set('X-Forwarded-For', request.headers.get('X-Forwarded-For') || 'unknown');\n    headers.set('X-Request-ID', generateRequestId());\n    \n    // Forward authentication header if present\n    const authHeader = request.headers.get('Authorization');\n    if (authHeader) {\n      headers.set('Authorization', authHeader);\n    }\n    \n    // Prepare request body for POST/PUT requests\n    let body: string | undefined;\n    if (method === 'POST' || method === 'PUT') {\n      try {\n        body = await request.text();\n      } catch (error) {\n        body = undefined;\n      }\n    }\n    \n    // Make request to backend service\n    const response = await fetch(`${targetUrl}/${path}`, {\n      method: method,\n      headers: headers,\n      body: body,\n      signal: AbortSignal.timeout(30000) // 30 second timeout\n    });\n    \n    // Prepare response headers\n    const responseHeaders = new Headers();\n    responseHeaders.set('Access-Control-Allow-Origin', '*');\n    responseHeaders.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n    responseHeaders.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');\n    \n    // Forward important headers from backend\n    const headersToForward = [\n      'Content-Type',\n      'Cache-Control',\n      'X-RateLimit-Limit',\n      'X-RateLimit-Remaining',\n      'X-RateLimit-Reset'\n    ];\n    \n    headersToForward.forEach(headerName => {\n      const headerValue = response.headers.get(headerName);\n      if (headerValue) {\n        responseHeaders.set(headerName, headerValue);\n      }\n    });\n    \n    // Add performance headers\n    responseHeaders.set('X-Proxy-Timestamp', new Date().toISOString());\n    responseHeaders.set('X-Response-Time', Date.now().toString());\n    \n    // Return response\n    const responseData = await response.text();\n    \n    return new Response(responseData, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: responseHeaders\n    });\n    \n  } catch (error) {\n    console.error('Proxy request failed:', error);\n    \n    return NextResponse.json(\n      { \n        error: 'Backend service unavailable',\n        timestamp: new Date().toISOString(),\n        requestId: generateRequestId()\n      },\n      { \n        status: 503,\n        headers: {\n          'Access-Control-Allow-Origin': '*',\n          'Retry-After': '30'\n        }\n      }\n    );\n  }\n}\n\nfunction getTargetUrl(path: string): string | null {\n  // Route to appropriate backend service based on path\n  const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080';\n  const strategyUrl = process.env.NEXT_PUBLIC_STRATEGY_SERVICE_URL || apiUrl;\n  const replayUrl = process.env.NEXT_PUBLIC_REPLAY_SERVICE_URL || apiUrl;\n  const forkUrl = process.env.NEXT_PUBLIC_FORK_SERVICE_URL || apiUrl;\n  \n  if (path.startsWith('strategy/')) {\n    return strategyUrl;\n  } else if (path.startsWith('replay/')) {\n    return replayUrl;\n  } else if (path.startsWith('fork/')) {\n    return forkUrl;\n  } else if (path.startsWith('health') || path.startsWith('api/')) {\n    return apiUrl;\n  }\n  \n  // Default to main API URL\n  return apiUrl;\n}\n\nasync function validateAuthentication(request: NextRequest, path: string): Promise<{ error?: string; status?: number }> {\n  // Paths that don't require authentication\n  const publicPaths = ['health', 'api/health', 'api/status'];\n  \n  if (publicPaths.some(publicPath => path.startsWith(publicPath))) {\n    return {};\n  }\n  \n  const authHeader = request.headers.get('Authorization');\n  \n  // For demonstration, we'll allow requests without auth but log them\n  if (!authHeader) {\n    console.warn('Request without authentication:', path);\n    return {}; // Allow for now, but in production this should return an error\n  }\n  \n  // Validate JWT token\n  if (!authHeader.startsWith('Bearer ')) {\n    return { error: 'Invalid authorization header format', status: 401 };\n  }\n  \n  const token = authHeader.slice(7);\n  \n  // Basic token validation - in production, verify JWT signature\n  if (token.length < 10) {\n    return { error: 'Invalid token', status: 401 };\n  }\n  \n  return {};\n}\n\nasync function checkRateLimit(request: NextRequest): Promise<{ error?: string }> {\n  // Simple rate limiting based on IP address\n  // In production, use a proper rate limiting service like Upstash Redis\n  \n  const forwardedFor = request.headers.get('X-Forwarded-For');\n  const ip = forwardedFor?.split(',')[0] || 'unknown';\n  \n  // For Edge Functions, we can't maintain state across requests\n  // This would need to be implemented with external storage (Redis, KV store)\n  // For now, we'll just log and allow\n  \n  console.log('Rate limit check for IP:', ip);\n  \n  return {};\n}\n\nfunction generateRequestId(): string {\n  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n} ","import { AppRouteRouteModule } from \"next/dist/server/future/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/future/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"/Users/taylormohney/Documents/GitHub/MEVDemo/web/dashboard/src/app/api/edge/proxy/route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/edge/proxy/route\",\n        pathname: \"/api/edge/proxy\",\n        filename: \"route\",\n        bundlePath: \"app/api/edge/proxy/route\"\n    },\n    resolvedPagePath: \"/Users/taylormohney/Documents/GitHub/MEVDemo/web/dashboard/src/app/api/edge/proxy/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/edge/proxy/route\";\nfunction patchFetch() {\n    return _patchFetch({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\nexport { routeModule, requestAsyncStorage, staticGenerationAsyncStorage, serverHooks, originalPathname, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","import { EdgeRouteModuleWrapper } from \"next/dist/server/web/edge-route-module-wrapper\";\n// Import the userland code.\nimport * as module from \"next-app-loader?name=app%2Fapi%2Fedge%2Fproxy%2Froute&page=%2Fapi%2Fedge%2Fproxy%2Froute&pagePath=private-next-app-dir%2Fapi%2Fedge%2Fproxy%2Froute.ts&appDir=%2FUsers%2Ftaylormohney%2FDocuments%2FGitHub%2FMEVDemo%2Fweb%2Fdashboard%2Fsrc%2Fapp&appPaths=%2Fapi%2Fedge%2Fproxy%2Froute&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!private-next-app-dir/api/edge/proxy/route.ts?__next_edge_ssr_entry__\";\nexport const ComponentMod = module;\nexport default EdgeRouteModuleWrapper.wrap(module.routeModule);\n\n//# sourceMappingURL=edge-app-route.js.map"],"names":["module","exports","require","runtime","GET","request","handleProxyRequest","POST","PUT","DELETE","OPTIONS","headers","Headers","set","Response","status","method","body","searchParams","pathname","URL","url","path","get","targetUrl","getTargetUrl","apiUrl","process","strategyUrl","env","NEXT_PUBLIC_STRATEGY_SERVICE_URL","replayUrl","NEXT_PUBLIC_REPLAY_SERVICE_URL","forkUrl","NEXT_PUBLIC_FORK_SERVICE_URL","startsWith","NextResponse","json","error","authResult","validateAuthentication","rateLimitResult","checkRateLimit","Math","floor","Date","now","toString","generateRequestId","authHeader","text","undefined","response","fetch","signal","AbortSignal","timeout","responseHeaders","headersToForward","forEach","headerName","headerValue","toISOString","responseData","statusText","console","timestamp","requestId","publicPaths","some","publicPath","token","slice","length","warn","forwardedFor","split","random","substr","routeModule","module_compiled","AppRouteRouteModule","definition","kind","route_kind","x","APP_ROUTE","page","filename","bundlePath","resolvedPagePath","nextConfigOutput","userland","route_namespaceObject","requestAsyncStorage","staticGenerationAsyncStorage","serverHooks","originalPathname","patchFetch","patch_fetch","XH","ComponentMod","route_next_edge_ssr_entry_namespaceObject","next_edge_app_route_loaderabsolutePagePath_private_next_app_dir_2Fapi_2Fedge_2Fproxy_2Froute_ts_page_2Fapi_2Fedge_2Fproxy_2Froute_appDirLoader_bmV4dC1hcHAtbG9hZGVyP25hbWU9YXBwJTJGYXBpJTJGZWRnZSUyRnByb3h5JTJGcm91dGUmcGFnZT0lMkZhcGklMkZlZGdlJTJGcHJveHklMkZyb3V0ZSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRmVkZ2UlMkZwcm94eSUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRnRheWxvcm1vaG5leSUyRkRvY3VtZW50cyUyRkdpdEh1YiUyRk1FVkRlbW8lMkZ3ZWIlMkZkYXNoYm9hcmQlMkZzcmMlMkZhcHAmYXBwUGF0aHM9JTJGYXBpJTJGZWRnZSUyRnByb3h5JTJGcm91dGUmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9c3RhbmRhbG9uZSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEIQ_3D_3D_nextConfigOutput_standalone_preferredRegion_middlewareConfig_e30_3D_","edge_route_module_wrapper","a","wrap"],"sourceRoot":""}