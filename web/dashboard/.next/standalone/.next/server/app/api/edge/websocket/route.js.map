{"version":3,"file":"app/api/edge/websocket/route.js","mappings":"oFAAAA,CAAAA,EAAAC,OAAA,CAAAC,QAAA,0CCAAF,CAAAA,EAAAC,OAAA,CAAAC,QAAA,8XCEO,IAAMC,EAAU,OAEhB,eAAeC,EAAIC,CAAoB,EAC5C,GAAM,CAAEC,aAAAA,CAAY,CAAE,CAAG,IAAIC,IAAIF,EAAQG,GAAG,EACtCC,EAAOH,EAAaI,GAAG,CAAC,SAAW,GAInCC,EAAY,0BAAeF,GAAM,CAMjCG,EAAU,IAAIC,QAMpB,OALAD,EAAQE,GAAG,CAAC,8BAA+B,KAC3CF,EAAQE,GAAG,CAAC,+BAAgC,sBAC5CF,EAAQE,GAAG,CAAC,+BAAgC,+BAGrCC,EAAAA,EAAYA,CAACC,IAAI,CAAC,CACvBC,aAAcN,EACdO,SAAU,YACVC,UAAW,IAAIC,OAAOC,WAAW,GACjCZ,KAAMA,CACR,EAAG,CACDa,OAAQ,IACRV,QAASA,CACX,EACF,CAEO,eAAeW,EAAKlB,CAAoB,EAC7C,GAAM,CAAEC,aAAAA,CAAY,CAAE,CAAG,IAAIC,IAAIF,EAAQG,GAAG,EACtCC,EAAOH,EAAaI,GAAG,CAAC,SAAW,EAG5B,OAAML,EAAQW,IAAI,GAG/B,IAAMQ,EAAYnB,EAAQO,OAAO,CAACF,GAAG,CAAC,iBACtC,GAAIc,GAAa,CA2CjB,IAAeC,EAAMC,UAAU,CAAC,YASzBC,EAJmBC,KAAK,CAAC,GAIbC,MAAM,CAAG,EAP5B,EA5CE,OAAOd,EAAAA,EAAYA,CAACC,IAAI,CACtB,CAAEc,MAAO,8BAA+B,EACxC,CAAER,OAAQ,GAAI,GAKlB,IAAMX,EAAY,0BAAeF,GAAM,CAGjCG,EAAU,IAAIC,QAKpB,OAJAD,EAAQE,GAAG,CAAC,8BAA+B,KAC3CF,EAAQE,GAAG,CAAC,+BAAgC,sBAC5CF,EAAQE,GAAG,CAAC,+BAAgC,+BAErCC,EAAAA,EAAYA,CAACC,IAAI,CAAC,CACvBC,aAAcN,EACdO,SAAU,YACVa,cAAe,CAAC,CAACP,EACjBL,UAAW,IAAIC,OAAOC,WAAW,GACjCZ,KAAMA,EACNuB,aAkCK,CAAC,KAAK,EAAEZ,KAAKa,GAAG,GAAG,CAAC,EAAEC,KAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,MAAM,CAAC,EAAG,GAAG,CAAC,EAjCnE,CACDf,OAAQ,IACRV,QAASA,CACX,EACF,CAEO,eAAe0B,EAAQjC,CAAoB,EAChD,IAAMO,EAAU,IAAIC,QAKpB,OAJAD,EAAQE,GAAG,CAAC,8BAA+B,KAC3CF,EAAQE,GAAG,CAAC,+BAAgC,sBAC5CF,EAAQE,GAAG,CAAC,+BAAgC,+BAErC,IAAIyB,SAAS,KAAM,CACxBjB,OAAQ,IACRV,QAASA,CACX,EACF,CC1EA,IAAA4B,EAAA,IAAwBC,EAAAC,mBAAmB,EAC3CC,WAAA,CACAC,KAAcC,EAAAC,CAAS,CAAAC,SAAA,CACvBC,KAAA,4BACAC,SAAA,sBACAC,SAAA,QACAC,WAAA,8BACA,EACAC,iBAAA,iGACAC,iBAVA,aAWAC,SAAYC,CACZ,GAIA,CAAQC,oBAAAA,CAAA,CAAAC,6BAAAA,CAAA,CAAAC,YAAAA,CAAA,EAAiElB,EACzEmB,EAAA,4BACA,SAAAC,IACA,MAAW,GAAAC,EAAAC,EAAA,EAAW,CACtBJ,YAAAA,EACAD,6BAAAA,CACA,EACA,CC1BO,IAAAM,EAAqBC,EAC5BC,EAAeC,EAAAC,CAAsB,CAAAC,IAAA,CAAM5B","sources":["webpack://_N_E/external commonjs \"node:async_hooks\"","webpack://_N_E/external commonjs \"node:buffer\"","webpack://_N_E/./src/app/api/edge/websocket/route.ts","webpack://_N_E/./src/app/api/edge/websocket/route.ts?0f03","webpack://_N_E/?c70a"],"sourcesContent":["module.exports = require(\"node:async_hooks\");","module.exports = require(\"node:buffer\");","import { NextRequest, NextResponse } from 'next/server';\n\nexport const runtime = 'edge';\n\nexport async function GET(request: NextRequest) {\n  const { searchParams } = new URL(request.url);\n  const path = searchParams.get('path') || '';\n  \n  // Get the target WebSocket URL from environment\n  const wsUrl = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8080';\n  const targetUrl = `${wsUrl}/ws/${path}`;\n  \n  // For WebSocket connections, we need to upgrade the connection\n  // In Edge Functions, we can't directly handle WebSocket upgrades\n  // Instead, we'll return connection details for the client to connect directly\n  \n  const headers = new Headers();\n  headers.set('Access-Control-Allow-Origin', '*');\n  headers.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n  headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  \n  // Return WebSocket connection information\n  return NextResponse.json({\n    websocketUrl: targetUrl,\n    protocol: 'websocket',\n    timestamp: new Date().toISOString(),\n    path: path\n  }, {\n    status: 200,\n    headers: headers\n  });\n}\n\nexport async function POST(request: NextRequest) {\n  const { searchParams } = new URL(request.url);\n  const path = searchParams.get('path') || '';\n  \n  // Handle WebSocket authentication and connection setup\n  const body = await request.json();\n  \n  // Validate authentication token if provided\n  const authToken = request.headers.get('Authorization');\n  if (authToken && !validateAuthToken(authToken)) {\n    return NextResponse.json(\n      { error: 'Invalid authentication token' },\n      { status: 401 }\n    );\n  }\n  \n  const wsUrl = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8080';\n  const targetUrl = `${wsUrl}/ws/${path}`;\n  \n  // Return authenticated WebSocket connection details\n  const headers = new Headers();\n  headers.set('Access-Control-Allow-Origin', '*');\n  headers.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n  headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  \n  return NextResponse.json({\n    websocketUrl: targetUrl,\n    protocol: 'websocket',\n    authenticated: !!authToken,\n    timestamp: new Date().toISOString(),\n    path: path,\n    connectionId: generateConnectionId()\n  }, {\n    status: 200,\n    headers: headers\n  });\n}\n\nexport async function OPTIONS(request: NextRequest) {\n  const headers = new Headers();\n  headers.set('Access-Control-Allow-Origin', '*');\n  headers.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n  headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  \n  return new Response(null, {\n    status: 200,\n    headers: headers\n  });\n}\n\nfunction validateAuthToken(token: string): boolean {\n  // Basic token validation - in production, this should validate JWT tokens\n  if (!token || !token.startsWith('Bearer ')) {\n    return false;\n  }\n  \n  // Extract token without \"Bearer \" prefix\n  const actualToken = token.slice(7);\n  \n  // Add your JWT validation logic here\n  // For now, just check if token exists and has minimum length\n  return actualToken.length > 10;\n}\n\nfunction generateConnectionId(): string {\n  return `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n} ","import { AppRouteRouteModule } from \"next/dist/server/future/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/future/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"/Users/taylormohney/Documents/GitHub/MEVDemo/web/dashboard/src/app/api/edge/websocket/route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/edge/websocket/route\",\n        pathname: \"/api/edge/websocket\",\n        filename: \"route\",\n        bundlePath: \"app/api/edge/websocket/route\"\n    },\n    resolvedPagePath: \"/Users/taylormohney/Documents/GitHub/MEVDemo/web/dashboard/src/app/api/edge/websocket/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/edge/websocket/route\";\nfunction patchFetch() {\n    return _patchFetch({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\nexport { routeModule, requestAsyncStorage, staticGenerationAsyncStorage, serverHooks, originalPathname, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","import { EdgeRouteModuleWrapper } from \"next/dist/server/web/edge-route-module-wrapper\";\n// Import the userland code.\nimport * as module from \"next-app-loader?name=app%2Fapi%2Fedge%2Fwebsocket%2Froute&page=%2Fapi%2Fedge%2Fwebsocket%2Froute&pagePath=private-next-app-dir%2Fapi%2Fedge%2Fwebsocket%2Froute.ts&appDir=%2FUsers%2Ftaylormohney%2FDocuments%2FGitHub%2FMEVDemo%2Fweb%2Fdashboard%2Fsrc%2Fapp&appPaths=%2Fapi%2Fedge%2Fwebsocket%2Froute&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!private-next-app-dir/api/edge/websocket/route.ts?__next_edge_ssr_entry__\";\nexport const ComponentMod = module;\nexport default EdgeRouteModuleWrapper.wrap(module.routeModule);\n\n//# sourceMappingURL=edge-app-route.js.map"],"names":["module","exports","require","runtime","GET","request","searchParams","URL","url","path","get","targetUrl","headers","Headers","set","NextResponse","json","websocketUrl","protocol","timestamp","Date","toISOString","status","POST","authToken","token","startsWith","actualToken","slice","length","error","authenticated","connectionId","now","Math","random","toString","substr","OPTIONS","Response","routeModule","module_compiled","AppRouteRouteModule","definition","kind","route_kind","x","APP_ROUTE","page","pathname","filename","bundlePath","resolvedPagePath","nextConfigOutput","userland","route_namespaceObject","requestAsyncStorage","staticGenerationAsyncStorage","serverHooks","originalPathname","patchFetch","patch_fetch","XH","ComponentMod","route_next_edge_ssr_entry_namespaceObject","next_edge_app_route_loaderabsolutePagePath_private_next_app_dir_2Fapi_2Fedge_2Fwebsocket_2Froute_ts_page_2Fapi_2Fedge_2Fwebsocket_2Froute_appDirLoader_bmV4dC1hcHAtbG9hZGVyP25hbWU9YXBwJTJGYXBpJTJGZWRnZSUyRndlYnNvY2tldCUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGZWRnZSUyRndlYnNvY2tldCUyRnJvdXRlJnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGZWRnZSUyRndlYnNvY2tldCUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRnRheWxvcm1vaG5leSUyRkRvY3VtZW50cyUyRkdpdEh1YiUyRk1FVkRlbW8lMkZ3ZWIlMkZkYXNoYm9hcmQlMkZzcmMlMkZhcHAmYXBwUGF0aHM9JTJGYXBpJTJGZWRnZSUyRndlYnNvY2tldCUyRnJvdXRlJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PXN0YW5kYWxvbmUmcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCE_3D_nextConfigOutput_standalone_preferredRegion_middlewareConfig_e30_3D_","edge_route_module_wrapper","a","wrap"],"sourceRoot":""}